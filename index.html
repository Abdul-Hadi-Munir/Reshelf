<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Hand Interface v3.1 - Stable</title>
    <style>
        :root {
            --primary: #00f3ff;
            --secondary: #ff0055;
            --warning: #ffcc00;
            --bg: #050505;
            --panel: rgba(5, 10, 15, 0.9);
            --font-main: 'Segoe UI', 'Roboto', Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: var(--font-main);
            user-select: none;
            color: white;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: none; /* Hidden until initialized */
        }

        .hud-panel {
            position: absolute;
            background: var(--panel);
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 6px;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        /* Top Left Stats */
        #stats-panel {
            top: 20px;
            left: 20px;
            width: 280px;
            border-left: 3px solid var(--primary);
            background: linear-gradient(90deg, rgba(0, 243, 255, 0.1) 0%, rgba(0,0,0,0) 100%), var(--panel);
        }

        /* Top Right Controls */
        #controls-panel {
            top: 20px;
            right: 20px;
            width: 320px;
            border-right: 3px solid var(--secondary);
            text-align: right;
            background: linear-gradient(-90deg, rgba(255, 0, 85, 0.1) 0%, rgba(0,0,0,0) 100%), var(--panel);
        }

        /* Bottom Mode Selector */
        #mode-selector {
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
        }

        .mode-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 12px 30px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 243, 255, 0.4), transparent);
            transition: 0.5s;
        }

        .mode-btn:hover::before { left: 100%; }

        .mode-btn:hover, .mode-btn.active {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 25px var(--primary);
            border-color: var(--primary);
        }

        .mode-btn.secondary { border-color: var(--secondary); color: var(--secondary); }
        .mode-btn.secondary:hover, .mode-btn.secondary.active {
            background: var(--secondary); color: #fff; box-shadow: 0 0 25px var(--secondary);
        }

        /* Typography */
        h1 { font-size: 20px; margin: 0 0 15px 0; color: var(--primary); letter-spacing: 2px; text-transform: uppercase; }
        h2 { font-size: 16px; margin: 0 0 10px 0; color: #fff; }
        p { font-size: 13px; color: #aaa; margin: 5px 0; line-height: 1.4; }
        
        .data-row { 
            display: flex; justify-content: space-between; 
            margin-bottom: 6px; 
            font-family: 'Courier New', Courier, monospace; 
            font-size: 12px; 
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding-bottom: 2px;
        }
        .data-label { color: #888; }
        .data-val { color: #fff; font-weight: bold; }
        .status-ok { color: var(--primary); }
        .status-warn { color: var(--warning); }
        .status-err { color: var(--secondary); }

        /* Video Feed */
        #video-container {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 260px;
            height: 195px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            overflow: hidden;
            z-index: 5;
            opacity: 0.6;
            transition: opacity 0.3s;
            transform: scaleX(-1);
            pointer-events: auto;
            background: #000;
        }
        #video-container:hover { opacity: 1; border-color: var(--primary); }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* Start / Error Screen */
        #overlay-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #020202;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-image: 
                radial-gradient(circle at 50% 50%, #111 0%, #000 70%),
                linear-gradient(0deg, rgba(0, 243, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.03) 1px, transparent 1px);
            background-size: 100% 100%, 40px 40px, 40px 40px;
        }

        #overlay-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
            border: 1px solid rgba(0, 243, 255, 0.2);
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
        }

        .title-glitch {
            font-size: 48px;
            font-weight: 800;
            color: #fff;
            text-shadow: 2px 2px var(--secondary), -2px -2px var(--primary);
            margin-bottom: 10px;
            letter-spacing: 4px;
        }

        .btn-large {
            margin-top: 30px;
            padding: 15px 50px;
            font-size: 18px;
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: 0.3s;
        }
        .btn-large:hover { background: var(--primary); color: #000; box-shadow: 0 0 40px var(--primary); }

        .btn-secondary {
            margin-top: 15px;
            padding: 10px 30px;
            font-size: 14px;
            background: transparent;
            color: #888;
            border: 1px solid #444;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: none; /* Hidden by default */
        }
        .btn-secondary:hover { border-color: #fff; color: #fff; }

        .error-box {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid var(--secondary);
            background: rgba(255, 0, 85, 0.1);
            color: #ffaaaa;
            font-family: monospace;
            display: none;
            text-align: left;
        }

        #loading-text {
            color: var(--primary);
            font-family: monospace;
            margin-top: 10px;
            font-size: 12px;
        }

        /* 3D Canvas */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
    </style>
</head>
<body>

    <!-- Start / Error Overlay -->
    <div id="overlay-screen">
        <div id="overlay-content">
            <div class="title-glitch">NEURAL INTERFACE</div>
            <p style="font-size: 16px; color: #ccc;">Gesture Control System v3.1</p>
            <div style="height: 2px; width: 100px; background: var(--primary); margin: 20px auto;"></div>
            
            <p>Requires <b>Camera Access</b> and <b>WebGL 2.0</b>.</p>
            <p style="font-size: 12px; color: #888;">Ensure you are running on <b>localhost</b> or <b>https</b>.<br>File protocol (file://) blocks camera access.</p>
            
            <button id="start-btn" class="btn-large" onclick="app.start()">INITIALIZE SYSTEM</button>
            <button id="mouse-mode-btn" class="btn-secondary" onclick="app.startMouseMode()">USE MOUSE MODE</button>
            
            <div id="loading-spinner" style="display:none; margin-top: 30px;">
                <div class="spinner-border"></div>
                <div id="loading-text">LOADING NEURAL NETWORKS...</div>
            </div>

            <div id="error-msg" class="error-box"></div>
        </div>
    </div>

    <!-- Main UI -->
    <div id="ui-layer">
        <!-- Stats -->
        <div id="stats-panel" class="hud-panel">
            <h1>SYSTEM STATUS</h1>
            <div class="data-row"><span class="data-label">FPS</span> <span id="fps-val" class="data-val">0</span></div>
            <div class="data-row"><span class="data-label">PHYSICS OBJECTS</span> <span id="physics-count" class="data-val">0</span></div>
            <div class="data-row"><span class="data-label">PARTICLES</span> <span id="particle-count" class="data-val">0</span></div>
            <div style="margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top:10px;">
                <div class="data-row"><span class="data-label">INPUT</span> <span id="hand-status" class="data-val status-warn">OFFLINE</span></div>
                <div class="data-row"><span class="data-label">GESTURE</span> <span id="gesture-val" class="data-val">NONE</span></div>
                <div class="data-row"><span class="data-label">CONFIDENCE</span> <span id="confidence-val" class="data-val">0%</span></div>
                <div class="data-row"><span class="data-label">VELOCITY</span> <span id="velocity-val" class="data-val">0.0 m/s</span></div>
            </div>
        </div>

        <!-- Controls -->
        <div id="controls-panel" class="hud-panel">
            <h1 style="color: var(--secondary);">OPERATOR GUIDE</h1>
            <p><b>MODE: <span id="mode-display" style="color: #fff">SANDBOX</span></b></p>
            <div style="margin: 15px 0; font-size: 13px;">
                <div style="margin-bottom: 8px;">üñê <b>OPEN PALM</b><br><span style="color:#aaa">Force Push / Repel Particles / Rotate View</span></div>
                <div style="margin-bottom: 8px;">‚úä <b>CLOSED FIST</b><br><span style="color:#aaa">Gravity Well / Grab Object / Red Shift</span></div>
                <div style="margin-bottom: 8px;">‚òù <b>INDEX POINT</b><br><span style="color:#aaa">Fire Projectile / Directional Laser</span></div>
                <div style="margin-bottom: 8px;">üëå <b>PINCH</b><br><span style="color:#aaa">Precision Draw / Spawn Entity</span></div>
            </div>
            <div class="data-row" style="margin-top: 20px;">
                <span class="data-label">AUDIO ENGINE</span>
                <span class="data-val status-ok">ACTIVE</span>
            </div>
        </div>

        <!-- Mode Selector -->
        <div id="mode-selector">
            <button class="mode-btn active" onclick="app.setMode('sandbox')">PHY_SANDBOX</button>
            <button class="mode-btn secondary" onclick="app.setMode('hologram')">HOLO_VIEW</button>
            <button class="mode-btn" onclick="app.setMode('particles')">PARTICLE_SYS</button>
        </div>
    </div>

    <!-- Video -->
    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <!-- Canvas -->
    <div id="canvas-container"></div>


    <!-- ======================= SCRIPTS ======================= -->

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Dependencies: Pinned Versions for Stability -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6.1675466023/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"></script>

    <!-- MAIN APPLICATION MODULE -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // ============================================================================
        // 1. SHADERS & CONSTANTS
        // ============================================================================

        const SHADERS = {
            // Particle Vertex Shader
            particleVertex: `
                attribute float size;
                attribute vec3 customColor;
                varying vec3 vColor;
                void main() {
                    vColor = customColor;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            // Particle Fragment Shader
            particleFragment: `
                uniform vec3 color;
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4(color * vColor, 1.0);
                    gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                    if (gl_FragColor.a < 0.1) discard;
                }
            `,
            // Hologram Vertex
            holoVertex: `
                varying vec2 vUv;
                varying vec3 vNormal;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            // Hologram Fragment (Scanline effect)
            holoFragment: `
                uniform float time;
                uniform vec3 color;
                varying vec2 vUv;
                varying vec3 vNormal;
                
                void main() {
                    // Fresnel rim lighting
                    vec3 viewDir = vec3(0.0, 0.0, 1.0);
                    float fresnel = pow(1.0 - dot(vNormal, viewDir), 3.0);
                    
                    // Scanlines
                    float scanline = sin(vUv.y * 50.0 - time * 5.0) * 0.5 + 0.5;
                    float glitch = step(0.98, sin(time * 10.0 + vUv.y * 10.0));
                    
                    vec3 finalColor = color * (fresnel + 0.2) + (scanline * 0.1);
                    finalColor += glitch * vec3(1.0); // White glitch
                    
                    gl_FragColor = vec4(finalColor, fresnel * 0.8 + 0.2);
                }
            `
        };

        // ============================================================================
        // 2. UTILITIES
        // ============================================================================

        const Utils = {
            randomRange: (min, max) => Math.random() * (max - min) + min,
            
            // Generates a soft glow texture for particles programmatically
            createSprite: () => {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.2, 'rgba(240,240,240,1)');
                grad.addColorStop(0.5, 'rgba(200,200,200,0.5)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,32,32);
                const tex = new THREE.CanvasTexture(canvas);
                return tex;
            },

            // Create a Cyberpunk Grid Texture
            createGridTexture: () => {
                const c = document.createElement('canvas');
                c.width = 512; c.height = 512;
                const ctx = c.getContext('2d');
                // Bg
                ctx.fillStyle = '#050505'; ctx.fillRect(0,0,512,512);
                // Grid
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00f3ff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00f3ff';
                ctx.beginPath();
                for(let i=0; i<=512; i+=64) {
                    ctx.moveTo(i,0); ctx.lineTo(i,512);
                    ctx.moveTo(0,i); ctx.lineTo(512,i);
                }
                ctx.stroke();
                // Tech markings
                ctx.fillStyle = '#ff0055';
                ctx.shadowColor = '#ff0055';
                for(let i=0; i<8; i++) {
                    const x = Math.floor(Math.random()*8)*64 + 10;
                    const y = Math.floor(Math.random()*8)*64 + 10;
                    ctx.fillRect(x,y,20,5);
                }
                const tex = new THREE.CanvasTexture(c);
                tex.wrapS = THREE.RepeatWrapping;
                tex.wrapT = THREE.RepeatWrapping;
                return tex;
            }
        };

        // ============================================================================
        // 3. AUDIO ENGINE (Advanced)
        // ============================================================================

        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.initialized = false;
            }

            async init() {
                if(this.initialized) return;
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.3;
                    this.masterGain.connect(this.ctx.destination);
                    
                    // Create ambient drone
                    this.createDrone();
                    this.initialized = true;
                } catch(e) {
                    console.warn("Audio init failed:", e);
                }
            }

            createDrone() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.type = 'sawtooth';
                osc.frequency.value = 40; // Low drone
                
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                
                gain.gain.value = 0.1;
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                
                // LFO for filter
                const lfo = this.ctx.createOscillator();
                lfo.frequency.value = 0.2;
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 100;
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                lfo.start();
            }

            playSFX(type) {
                if(!this.initialized) return;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                if (type === 'hover') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(600, this.ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
                } else if (type === 'grab') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                } else if (type === 'shoot') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
                }

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            }
        }

        // ============================================================================
        // 4. PHYSICS ENGINE (Cannon.js)
        // ============================================================================

        class PhysicsEngine {
            constructor() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.world.broadphase = new CANNON.SAPBroadphase(this.world);
                this.world.solver.iterations = 10;

                // Materials
                this.matDefault = new CANNON.Material();
                this.matGround = new CANNON.Material();
                
                const contactMat = new CANNON.ContactMaterial(this.matGround, this.matDefault, {
                    friction: 0.4, restitution: 0.5
                });
                this.world.addContactMaterial(contactMat);

                // Ground
                const groundBody = new CANNON.Body({ mass: 0, material: this.matGround });
                groundBody.addShape(new CANNON.Plane());
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
                this.world.addBody(groundBody);
                
                this.bodies = []; // Track active bodies
            }

            addBody(mesh, type='box', mass=1, size=1) {
                const shape = type === 'box' 
                    ? new CANNON.Box(new CANNON.Vec3(size/2, size/2, size/2))
                    : new CANNON.Sphere(size);
                
                const body = new CANNON.Body({ mass: mass, material: this.matDefault });
                body.addShape(shape);
                body.position.copy(mesh.position);
                body.quaternion.copy(mesh.quaternion);
                
                // Damping to stop things flying endlessly
                body.linearDamping = 0.1;
                body.angularDamping = 0.1;
                
                this.world.addBody(body);
                this.bodies.push({ mesh, body, type });
                return body;
            }

            removeBody(obj) {
                this.world.removeBody(obj.body);
                this.bodies = this.bodies.filter(b => b !== obj);
            }

            update(dt) {
                this.world.step(1/60, dt, 3);
                
                // Sync Visuals
                for (const obj of this.bodies) {
                    obj.mesh.position.copy(obj.body.position);
                    obj.mesh.quaternion.copy(obj.body.quaternion);
                    
                    // Simple "kill" floor
                    if(obj.body.position.y < -10) {
                        obj.body.position.set(0, 5, 0);
                        obj.body.velocity.set(0,0,0);
                    }
                }
            }
            
            clear() {
                this.bodies.forEach(b => this.world.removeBody(b.body));
                this.bodies = [];
            }
        }

        // ============================================================================
        // 5. PARTICLE SYSTEM (GPU)
        // ============================================================================

        class ParticleSystem {
            constructor(scene, count=10000) {
                this.count = count;
                this.scene = scene;
                this.geometry = new THREE.BufferGeometry();
                this.material = null;
                this.mesh = null;
                this.positions = new Float32Array(count * 3);
                this.velocities = new Float32Array(count * 3);
                this.colors = new Float32Array(count * 3);
                this.sizes = new Float32Array(count);
                
                this.init();
            }

            init() {
                const color = new THREE.Color();
                
                for(let i=0; i<this.count; i++) {
                    const i3 = i*3;
                    this.positions[i3] = (Math.random() - 0.5) * 20;
                    this.positions[i3+1] = (Math.random() - 0.5) * 20 + 5;
                    this.positions[i3+2] = (Math.random() - 0.5) * 10;
                    
                    this.velocities[i3] = (Math.random() - 0.5) * 0.1;
                    this.velocities[i3+1] = (Math.random() - 0.5) * 0.1;
                    this.velocities[i3+2] = (Math.random() - 0.5) * 0.1;
                    
                    color.setHSL(Math.random() * 0.1 + 0.5, 0.8, 0.5); // Blue/Cyan range
                    this.colors[i3] = color.r;
                    this.colors[i3+1] = color.g;
                    this.colors[i3+2] = color.b;
                    
                    this.sizes[i] = Math.random() * 2;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('customColor', new THREE.BufferAttribute(this.colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new THREE.Color(0xffffff) },
                        pointTexture: { value: Utils.createSprite() }
                    },
                    vertexShader: SHADERS.particleVertex,
                    fragmentShader: SHADERS.particleFragment,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true
                });
                
                this.mesh = new THREE.Points(this.geometry, this.material);
                this.scene.add(this.mesh);
                this.mesh.visible = false;
            }

            update(targetPos, isAttracting, isRepelling, dt) {
                if(!this.mesh.visible) return;
                
                const positions = this.geometry.attributes.position.array;
                
                for(let i=0; i<this.count; i++) {
                    const i3 = i*3;
                    
                    // Basic Brownian motion
                    let vx = this.velocities[i3];
                    let vy = this.velocities[i3+1];
                    let vz = this.velocities[i3+2];
                    
                    let px = positions[i3];
                    let py = positions[i3+1];
                    let pz = positions[i3+2];
                    
                    // Interaction
                    if(targetPos) {
                        const dx = targetPos.x - px;
                        const dy = targetPos.y - py;
                        const dz = targetPos.z - pz;
                        const distSq = dx*dx + dy*dy + dz*dz;
                        
                        if(distSq < 25) { // Influence radius
                            const force = 10 / (distSq + 0.1);
                            if(isAttracting) {
                                vx += dx * force * dt;
                                vy += dy * force * dt;
                                vz += dz * force * dt;
                            } else if (isRepelling) {
                                vx -= dx * force * 2 * dt;
                                vy -= dy * force * 2 * dt;
                                vz -= dz * force * 2 * dt;
                            } else {
                                // Gentle swirl
                                vx += -dz * force * 0.5 * dt;
                                vz += dx * force * 0.5 * dt;
                            }
                        }
                    }
                    
                    // Dampen
                    vx *= 0.98;
                    vy *= 0.98;
                    vz *= 0.98;
                    
                    // Apply
                    px += vx;
                    py += vy;
                    pz += vz;
                    
                    // Bounds check (respawn)
                    if(Math.abs(px) > 15 || Math.abs(py-5) > 10 || Math.abs(pz) > 10) {
                        px = (Math.random() - 0.5) * 10;
                        py = (Math.random() - 0.5) * 10 + 5;
                        pz = (Math.random() - 0.5) * 10;
                        vx = 0; vy = 0; vz = 0;
                    }
                    
                    positions[i3] = px;
                    positions[i3+1] = py;
                    positions[i3+2] = pz;
                    
                    this.velocities[i3] = vx;
                    this.velocities[i3+1] = vy;
                    this.velocities[i3+2] = vz;
                }
                
                this.geometry.attributes.position.needsUpdate = true;
            }
        }

        // ============================================================================
        // 6. VISUAL ENGINE (Three.js)
        // ============================================================================

        class VisualEngine {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.015);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
                this.camera.position.set(0, 4, 10);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.toneMapping = THREE.ReinhardToneMapping;
                this.container.appendChild(this.renderer.domElement);
                
                // Composer (Bloom)
                this.composer = new EffectComposer(this.renderer);
                const renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);
                
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.strength = 1.2;
                bloomPass.radius = 0.5;
                bloomPass.threshold = 0.1;
                this.composer.addPass(bloomPass);

                // Controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // Environment
                this.setupEnvironment();
                
                // Hand Visualizer
                this.handMesh = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(0.2, 1),
                    new THREE.MeshBasicMaterial({ color: 0x00f3ff, wireframe: true, transparent: true, opacity: 0.8 })
                );
                this.scene.add(this.handMesh);

                // Laser Line (for pointing)
                const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-10)]);
                this.laserLine = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0 }));
                this.scene.add(this.laserLine);
                
                this.projectiles = [];
            }

            setupEnvironment() {
                // Lights
                const ambient = new THREE.AmbientLight(0x222222);
                this.scene.add(ambient);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(5, 10, 7);
                this.scene.add(dirLight);

                const blueLight = new THREE.PointLight(0x00f3ff, 2, 20);
                blueLight.position.set(-5, 5, 0);
                this.scene.add(blueLight);
                
                const redLight = new THREE.PointLight(0xff0055, 2, 20);
                redLight.position.set(5, 5, 0);
                this.scene.add(redLight);

                // Floor
                const grid = new THREE.GridHelper(60, 60, 0x333333, 0x111111);
                this.scene.add(grid);
            }
            
            spawnProjectile(pos, dir) {
                const geo = new THREE.SphereGeometry(0.1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                this.scene.add(mesh);
                
                // Velocity
                const vel = dir.clone().normalize().multiplyScalar(0.5); // speed
                this.projectiles.push({ mesh, vel, life: 100 });
            }

            updateProjectiles() {
                for(let i=this.projectiles.length-1; i>=0; i--) {
                    const p = this.projectiles[i];
                    p.mesh.position.add(p.vel);
                    p.life--;
                    if(p.life <= 0) {
                        this.scene.remove(p.mesh);
                        this.projectiles.splice(i, 1);
                    }
                }
            }

            resize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            render() {
                this.composer.render();
            }
        }

        // ============================================================================
        // 7. HAND TRACKING & LOGIC
        // ============================================================================

        class HandController {
            constructor(videoEl, onData, onStatus) {
                this.videoEl = videoEl;
                this.onData = onData;
                this.onStatus = onStatus || (() => {});
                
                // Important: Use pinned versions in locateFile to match script tags
                this.hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
                });
                
                this.hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.6
                });

                this.hands.onResults(this.process.bind(this));
                
                this.lastPos = new THREE.Vector3();
                this.velocity = new THREE.Vector3();
                this.lastTime = 0;
            }

            async start() {
                // 1. Request Camera
                this.onStatus("Requesting Camera Access...");
                let stream;
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                    this.videoEl.srcObject = stream;
                    this.onStatus("Camera Access Granted. Initializing Video...");
                    await this.videoEl.play();
                } catch (err) {
                    throw new Error("Camera Access Denied: " + err.message);
                }

                // 2. Start MediaPipe
                this.onStatus("Downloading AI Models...");
                
                // Using Camera Util with explicit error handling wrapper
                return new Promise((resolve, reject) => {
                    const cam = new Camera(this.videoEl, {
                        onFrame: async () => {
                            try {
                                await this.hands.send({image: this.videoEl});
                            } catch(e) {
                                console.error("MediaPipe Error:", e);
                            }
                        },
                        width: 640, height: 480
                    });

                    cam.start()
                        .then(() => {
                            this.onStatus("System Ready.");
                            resolve();
                        })
                        .catch(err => reject(err));
                        
                    // Timeout safety
                    setTimeout(() => {
                        // Sometimes start() promise doesn't resolve if stream is active but model hangs
                        // We resolve anyway if stream is active so app doesn't freeze
                        if (this.videoEl.readyState >= 2) resolve(); 
                    }, 5000);
                });
            }

            process(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const handedness = results.multiHandedness[0].label;
                    
                    const x = (0.5 - lm[9].x) * 18; 
                    const y = (1.0 - lm[9].y) * 12;
                    const palmSize = Math.abs(lm[0].y - lm[9].y); 
                    const z = (palmSize - 0.2) * 20;

                    const pos = new THREE.Vector3(x, y, z);
                    
                    const now = performance.now();
                    const dt = (now - this.lastTime) / 1000;
                    if(dt > 0) {
                        const delta = pos.clone().sub(this.lastPos);
                        this.velocity.lerp(delta.divideScalar(dt), 0.3); 
                    }
                    this.lastPos.copy(pos);
                    this.lastTime = now;

                    const gesture = this.recognizeGesture(lm);
                    
                    this.onData({
                        found: true,
                        pos: pos,
                        vel: this.velocity,
                        gesture: gesture,
                        raw: lm,
                        confidence: results.multiHandedness[0].score
                    });

                } else {
                    this.onData({ found: false });
                }
            }

            recognizeGesture(lm) {
                const isIndexOpen = lm[8].y < lm[6].y;
                const isMiddleOpen = lm[12].y < lm[10].y;
                const isRingOpen = lm[16].y < lm[14].y;
                const isPinkyOpen = lm[20].y < lm[18].y;

                const pinchDist = this.dist(lm[4], lm[8]);
                if (pinchDist < 0.05) return 'PINCH';

                if (!isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) return 'FIST';
                if (isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) return 'POINT';
                if (isIndexOpen && isMiddleOpen && isRingOpen) return 'OPEN';

                return 'UNKNOWN';
            }

            dist(p1, p2) {
                return Math.sqrt(Math.pow(p1.x-p2.x, 2) + Math.pow(p1.y-p2.y, 2));
            }
        }

        // ============================================================================
        // 8. MOUSE FALLBACK CONTROLLER
        // ============================================================================
        class MouseController {
            constructor(onData) {
                this.onData = onData;
                this.active = false;
                this.pos = new THREE.Vector3(0,0,0);
                this.gesture = 'OPEN';
                
                window.addEventListener('mousemove', (e) => {
                    if(!this.active) return;
                    // Map screen to 3D world approx
                    this.pos.x = (e.clientX / window.innerWidth) * 20 - 10;
                    this.pos.y = -(e.clientY / window.innerHeight) * 14 + 7;
                    this.pos.z = 0;
                    
                    this.emit();
                });

                window.addEventListener('mousedown', (e) => {
                    this.gesture = 'FIST';
                    this.emit();
                });

                window.addEventListener('mouseup', (e) => {
                    this.gesture = 'OPEN';
                    this.emit();
                });
                
                window.addEventListener('keydown', (e) => {
                    if(e.key === ' ') this.gesture = 'POINT';
                    this.emit();
                });
                 window.addEventListener('keyup', (e) => {
                    if(e.key === ' ') this.gesture = 'OPEN';
                    this.emit();
                });
            }

            start() {
                this.active = true;
                this.emit();
            }

            emit() {
                if(!this.active) return;
                this.onData({
                    found: true,
                    pos: this.pos,
                    vel: new THREE.Vector3(0,0,0),
                    gesture: this.gesture,
                    confidence: 1.0
                });
            }
        }

        // ============================================================================
        // 9. MAIN APPLICATION
        // ============================================================================

        class App {
            constructor() {
                this.mode = 'sandbox'; // sandbox, hologram, particles
                this.isRunning = false;
                
                // UI Refs
                this.ui = {
                    fps: document.getElementById('fps-val'),
                    hand: document.getElementById('hand-status'),
                    gesture: document.getElementById('gesture-val'),
                    conf: document.getElementById('confidence-val'),
                    vel: document.getElementById('velocity-val'),
                    mode: document.getElementById('mode-display'),
                    phys: document.getElementById('physics-count'),
                    part: document.getElementById('particle-count'),
                    error: document.getElementById('error-msg'),
                    spinner: document.getElementById('loading-spinner'),
                    loadText: document.getElementById('loading-text'),
                    mouseBtn: document.getElementById('mouse-mode-btn')
                };

                // Systems
                this.audio = new AudioEngine();
                this.physics = new PhysicsEngine();
                this.visuals = new VisualEngine();
                this.particles = new ParticleSystem(this.visuals.scene);
                
                this.handCtrl = new HandController(
                    document.getElementById('input-video'), 
                    this.handleInput.bind(this),
                    (status) => this.ui.loadText.innerText = status
                );
                
                this.mouseCtrl = new MouseController(this.handleInput.bind(this));

                // State
                this.heldObject = null;
                this.shootCooldown = 0;

                // Resize handler
                window.addEventListener('resize', () => this.visuals.resize());

                // Protocol Check
                if(location.protocol === 'file:') {
                    this.showError("SECURITY BLOCK: Browser blocks camera on file:// protocol.\nPlease use a local server (e.g., Live Server extension).");
                }
            }

            async start() {
                document.getElementById('start-btn').style.display = 'none';
                this.ui.mouseBtn.style.display = 'none';
                this.ui.spinner.style.display = 'block';
                
                await this.audio.init();

                // Race Condition: If camera takes too long, show mouse button
                const timeout = setTimeout(() => {
                    if(!this.isRunning) {
                        this.ui.loadText.innerText = "Taking a long time... Check Camera Permissions.";
                        this.ui.mouseBtn.style.display = 'block';
                    }
                }, 8000);

                try {
                    await this.handCtrl.start();
                    clearTimeout(timeout);
                    this.launch();
                } catch (e) {
                    clearTimeout(timeout);
                    this.showError("CAMERA ERROR: " + e.message);
                    this.ui.spinner.style.display = 'none';
                    this.ui.mouseBtn.style.display = 'block'; // Offer fallback
                }
            }

            startMouseMode() {
                document.getElementById('start-btn').style.display = 'none';
                this.ui.mouseBtn.style.display = 'none';
                this.ui.spinner.style.display = 'none';
                this.ui.hand.innerText = "MOUSE MODE";
                
                this.mouseCtrl.start();
                this.launch();
            }

            launch() {
                document.getElementById('overlay-screen').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
                this.isRunning = true;
                this.setMode('sandbox');
                this.loop();
            }

            showError(msg) {
                this.ui.error.style.display = 'block';
                this.ui.error.innerText = msg;
            }

            setMode(mode) {
                this.mode = mode;
                this.ui.mode.innerText = mode.toUpperCase();
                
                // Update Buttons
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                const idx = mode === 'sandbox' ? 0 : mode === 'hologram' ? 1 : 2;
                document.querySelectorAll('.mode-btn')[idx].classList.add('active');

                // Cleanup
                this.physics.clear();
                this.particles.mesh.visible = false;
                if(this.hologram) {
                    this.visuals.scene.remove(this.hologram);
                    this.hologram = null;
                }

                // Setup New Mode
                if (mode === 'sandbox') {
                    this.spawnCity();
                } else if (mode === 'particles') {
                    this.particles.mesh.visible = true;
                } else if (mode === 'hologram') {
                    this.spawnHologram();
                }
            }

            spawnCity() {
                // Procedurally generate physics boxes
                const texture = Utils.createGridTexture();
                const mat = new THREE.MeshStandardMaterial({ 
                    map: texture, 
                    color: 0x00f3ff,
                    roughness: 0.2,
                    metalness: 0.8,
                    emissive: 0x000022
                });

                for(let i=0; i<5; i++) {
                    for(let j=0; j<3; j++) {
                        const height = Utils.randomRange(1, 4);
                        const box = new THREE.Mesh(new THREE.BoxGeometry(1, height, 1), mat.clone());
                        box.position.set((i-2)*2, height/2 + 2, (j-1)*2);
                        this.visuals.scene.add(box);
                        this.physics.addBody(box, 'box', 1, 1); // approximate
                    }
                }
            }

            spawnHologram() {
                const geo = new THREE.TorusKnotGeometry(1.5, 0.4, 100, 16);
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        color: { value: new THREE.Color(0xff0055) }
                    },
                    vertexShader: SHADERS.holoVertex,
                    fragmentShader: SHADERS.holoFragment,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                this.hologram = new THREE.Mesh(geo, mat);
                this.hologram.position.set(0, 5, 0);
                this.visuals.scene.add(this.hologram);
            }

            handleInput(data) {
                if(!data.found) {
                    if(this.ui.hand.innerText !== "MOUSE MODE") {
                        this.ui.hand.innerText = "SEARCHING";
                        this.ui.hand.className = "data-val status-warn";
                    }
                    this.visuals.laserLine.material.opacity = 0;
                    return;
                }

                // Update UI
                if(this.ui.hand.innerText !== "MOUSE MODE") {
                    this.ui.hand.innerText = "TRACKING";
                    this.ui.hand.className = "data-val status-ok";
                }
                this.ui.gesture.innerText = data.gesture;
                this.ui.conf.innerText = Math.round(data.confidence * 100) + "%";
                this.ui.vel.innerText = data.vel.length().toFixed(1) + " m/s";

                // Visual Feedback
                this.visuals.updateHandVisuals(data.pos, data.gesture);

                // --- MODE LOGIC ---
                if (this.mode === 'sandbox') {
                    this.logicSandbox(data);
                } else if (this.mode === 'particles') {
                    this.logicParticles(data);
                } else if (this.mode === 'hologram') {
                    this.logicHologram(data);
                }

                // Global Interactions (Shooting)
                if (data.gesture === 'POINT') {
                    this.visuals.laserLine.material.opacity = 0.8;
                    const tip = data.pos.clone();
                    const end = tip.clone().add(new THREE.Vector3(0,0,-10));
                    this.visuals.laserLine.geometry.setFromPoints([tip, end]);
                    this.visuals.laserLine.geometry.attributes.position.needsUpdate = true;
                    
                    if(this.shootCooldown <= 0) {
                        this.visuals.spawnProjectile(tip, new THREE.Vector3(0, 0, -1));
                        this.audio.playSFX('shoot');
                        this.shootCooldown = 20; // frames
                    }
                } else {
                    this.visuals.laserLine.material.opacity = 0;
                }
                this.shootCooldown--;
            }

            logicSandbox(data) {
                // Force Push (Open Hand)
                if (data.gesture === 'OPEN') {
                    for(let obj of this.physics.bodies) {
                        const dist = obj.mesh.position.distanceTo(data.pos);
                        if(dist < 5) {
                            const dir = obj.mesh.position.clone().sub(data.pos).normalize();
                            const force = 15 / (dist + 0.1);
                            obj.body.velocity.x += dir.x * force * 0.5;
                            obj.body.velocity.y += dir.y * force * 0.5;
                            obj.body.velocity.z += dir.z * force * 0.5;
                            obj.mesh.material.emissive.setHex(0x00f3ff);
                        } else {
                            obj.mesh.material.emissive.setHex(0x000022);
                        }
                    }
                }

                // Grab (Fist)
                if (data.gesture === 'FIST') {
                    if(!this.heldObject) {
                        // Find closest
                        let closest = null;
                        let minD = 3;
                        for(let obj of this.physics.bodies) {
                            const d = obj.mesh.position.distanceTo(data.pos);
                            if(d < minD) { minD = d; closest = obj; }
                        }
                        if(closest) {
                            this.heldObject = closest;
                            this.audio.playSFX('grab');
                        }
                    }
                    
                    if(this.heldObject) {
                        // Move body to hand
                        this.heldObject.body.position.copy(data.pos);
                        this.heldObject.body.velocity.set(0,0,0);
                        this.heldObject.mesh.material.emissive.setHex(0xff0055);
                    }
                } else {
                    if(this.heldObject) {
                        // Throw
                        this.heldObject.body.velocity.copy(data.vel).multiplyScalar(2.0); // Multiply throw force
                        this.heldObject.mesh.material.emissive.setHex(0x000022);
                        this.heldObject = null;
                    }
                }
            }

            logicParticles(data) {
                const isAttract = data.gesture === 'FIST';
                const isRepel = data.gesture === 'OPEN';
                this.particles.update(data.pos, isAttract, isRepel, 0.016);
                
                // Audio feedback
                if(isAttract) this.audio.playSFX('hover');
            }

            logicHologram(data) {
                if(!this.hologram) return;
                
                // Rotation
                this.hologram.rotation.y += data.vel.x * 0.1;
                this.hologram.rotation.x += data.vel.y * 0.1;
                
                // Shader update
                this.hologram.material.uniforms.time.value = performance.now() / 1000;
                
                if(data.gesture === 'FIST') {
                    this.hologram.material.uniforms.color.value.setHex(0xff0055); // Red alert
                } else {
                    this.hologram.material.uniforms.color.value.setHex(0x00f3ff); // Normal
                }
            }

            loop() {
                if(!this.isRunning) return;
                requestAnimationFrame(this.loop.bind(this));

                const dt = 1/60;

                // Updates
                this.physics.update(dt);
                this.visuals.updateProjectiles();
                
                // UI Stats
                this.ui.fps.innerText = Math.round(1000 / (performance.now() - this.lastTime || 16));
                this.lastTime = performance.now();
                this.ui.phys.innerText = this.physics.bodies.length;
                this.ui.part.innerText = this.mode === 'particles' ? this.particles.count : 0;

                // Render
                this.visuals.render();
            }
        }

        // Initialize Global App
        window.app = new App();

    </script>
</body>
</html>
